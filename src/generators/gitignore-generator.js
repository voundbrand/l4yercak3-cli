/**
 * Gitignore Generator
 * Updates .gitignore to ensure sensitive files are not committed
 */

const fs = require('fs');
const path = require('path');

class GitignoreGenerator {
  /**
   * Update .gitignore file
   */
  generate(options) {
    const { projectPath } = options;
    const gitignorePath = path.join(projectPath, '.gitignore');
    
    // Required entries to ensure are present
    const requiredEntries = [
      '# L4YERCAK3 Configuration',
      '.env.local',
      '.env*.local',
      '.l4yercak3/',
    ];

    let gitignoreContent = '';
    let needsUpdate = false;

    // Read existing .gitignore if it exists
    if (fs.existsSync(gitignorePath)) {
      gitignoreContent = fs.readFileSync(gitignorePath, 'utf8');
    }

    // Check if required entries are missing
    for (const entry of requiredEntries) {
      // Skip comment lines for checking
      if (entry.startsWith('#')) {
        if (!gitignoreContent.includes(entry)) {
          needsUpdate = true;
        }
      } else {
        // Check for the actual entry (with or without leading/trailing whitespace)
        const entryRegex = new RegExp(`^\\s*${entry.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*$`, 'm');
        if (!entryRegex.test(gitignoreContent)) {
          needsUpdate = true;
        }
      }
    }

    // If no update needed, return null
    if (!needsUpdate && gitignoreContent) {
      return null;
    }

    // Append required entries if they're missing
    if (needsUpdate) {
      if (gitignoreContent && !gitignoreContent.endsWith('\n')) {
        gitignoreContent += '\n';
      }
      
      // Add section header if not present
      if (!gitignoreContent.includes('# L4YERCAK3 Configuration')) {
        gitignoreContent += '\n# L4YERCAK3 Configuration\n';
        gitignoreContent += '# Auto-generated by @l4yercak3/cli\n';
        gitignoreContent += '# DO NOT commit sensitive configuration files\n\n';
      }

      // Add entries if missing
      const entriesToAdd = [
        '.env.local',
        '.env*.local',
        '.l4yercak3/',
      ];

      for (const entry of entriesToAdd) {
        const entryRegex = new RegExp(`^\\s*${entry.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*$`, 'm');
        if (!entryRegex.test(gitignoreContent)) {
          gitignoreContent += `${entry}\n`;
        }
      }
    }

    // Write updated .gitignore
    fs.writeFileSync(gitignorePath, gitignoreContent, 'utf8');
    return gitignorePath;
  }
}

module.exports = new GitignoreGenerator();




