/**
 * Supabase Database Generator
 * Generates Supabase schema, migrations, and client for L4YERCAK3 integration
 */

const path = require('path');
const { ensureDir, writeFileWithBackup, checkFileOverwrite } = require('../../../utils/file-utils');

class SupabaseGenerator {
  /**
   * Generate Supabase database files
   * @param {Object} options - Generation options
   * @returns {Promise<Object>} - Generated file paths
   */
  async generate(options) {
    const { projectPath, features = [] } = options;

    const results = {
      schema: null,
      client: null,
      types: null,
      middleware: null,
    };

    const supabaseDir = path.join(projectPath, 'supabase');
    const migrationsDir = path.join(supabaseDir, 'migrations');
    ensureDir(supabaseDir);
    ensureDir(migrationsDir);

    // Generate initial migration
    results.schema = await this.generateMigration(migrationsDir, features);

    // Generate Supabase client
    results.client = await this.generateClient(projectPath, options);

    // Generate TypeScript types
    if (options.isTypeScript) {
      results.types = await this.generateTypes(projectPath);
    }

    // Generate middleware for auth
    if (features.includes('oauth')) {
      results.middleware = await this.generateMiddleware(projectPath, options);
    }

    return results;
  }

  async generateMigration(migrationsDir, _features) {
    const timestamp = new Date().toISOString().replace(/[-:T]/g, '').slice(0, 14);
    const outputPath = path.join(migrationsDir, `${timestamp}_l4yercak3_schema.sql`);

    const action = await checkFileOverwrite(outputPath);
    if (action === 'skip') {
      return null;
    }

    const content = `-- L4YERCAK3 Integration Schema
-- Auto-generated by @l4yercak3/cli
--
-- This schema follows the ontology-first pattern, mirroring
-- L4YERCAK3's universal object structure for seamless sync.

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================
-- ONTOLOGY: Universal object storage
-- ============================================

CREATE TYPE sync_status AS ENUM (
  'synced',
  'pending_push',
  'pending_pull',
  'conflict',
  'local_only'
);

CREATE TABLE objects (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  l4yercak3_id TEXT UNIQUE,
  organization_id TEXT NOT NULL,

  -- Core fields
  type TEXT NOT NULL,
  subtype TEXT,
  name TEXT NOT NULL,
  status TEXT NOT NULL,

  -- Type-specific data
  custom_properties JSONB DEFAULT '{}',

  -- Sync tracking
  sync_status sync_status DEFAULT 'local_only',
  synced_at TIMESTAMPTZ,
  local_version INTEGER DEFAULT 1,
  remote_version INTEGER,

  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  deleted_at TIMESTAMPTZ
);

-- Indexes for objects
CREATE INDEX idx_objects_l4yercak3_id ON objects(l4yercak3_id);
CREATE INDEX idx_objects_type ON objects(type);
CREATE INDEX idx_objects_type_status ON objects(type, status);
CREATE INDEX idx_objects_type_subtype ON objects(type, subtype);
CREATE INDEX idx_objects_sync_status ON objects(sync_status);
CREATE INDEX idx_objects_organization ON objects(organization_id);
CREATE INDEX idx_objects_updated ON objects(updated_at DESC);

-- Object relationships
CREATE TABLE object_links (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  l4yercak3_id TEXT,
  from_object_id UUID REFERENCES objects(id) ON DELETE CASCADE,
  to_object_id UUID REFERENCES objects(id) ON DELETE CASCADE,
  link_type TEXT NOT NULL,
  metadata JSONB,
  sync_status TEXT DEFAULT 'local_only',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_object_links_from ON object_links(from_object_id);
CREATE INDEX idx_object_links_to ON object_links(to_object_id);
CREATE INDEX idx_object_links_from_type ON object_links(from_object_id, link_type);

-- ============================================
-- AUTHENTICATION: Local user management
-- ============================================

CREATE TABLE frontend_users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  l4yercak3_contact_id TEXT,
  l4yercak3_frontend_user_id TEXT,
  organization_id TEXT NOT NULL,

  -- Core identity
  email TEXT UNIQUE NOT NULL,
  email_verified BOOLEAN DEFAULT FALSE,
  name TEXT,
  first_name TEXT,
  last_name TEXT,
  image TEXT,
  phone TEXT,

  -- Local auth
  password_hash TEXT,

  -- OAuth accounts stored as JSONB array
  oauth_accounts JSONB DEFAULT '[]',

  -- App-specific
  role TEXT DEFAULT 'user',
  preferences JSONB DEFAULT '{}',

  -- Sync
  sync_status TEXT DEFAULT 'pending_push',
  synced_at TIMESTAMPTZ,

  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  last_login_at TIMESTAMPTZ
);

CREATE INDEX idx_frontend_users_email ON frontend_users(email);
CREATE INDEX idx_frontend_users_l4yercak3_contact ON frontend_users(l4yercak3_contact_id);
CREATE INDEX idx_frontend_users_organization ON frontend_users(organization_id);

-- Sessions
CREATE TABLE sessions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES frontend_users(id) ON DELETE CASCADE,
  session_token TEXT UNIQUE NOT NULL,
  expires_at TIMESTAMPTZ NOT NULL,
  user_agent TEXT,
  ip_address TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_sessions_token ON sessions(session_token);
CREATE INDEX idx_sessions_user ON sessions(user_id);

-- ============================================
-- STRIPE: Local payment handling
-- ============================================

CREATE TABLE stripe_customers (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  frontend_user_id UUID REFERENCES frontend_users(id) ON DELETE CASCADE,
  stripe_customer_id TEXT UNIQUE NOT NULL,
  l4yercak3_contact_id TEXT,
  email TEXT NOT NULL,
  name TEXT,
  default_payment_method_id TEXT,
  sync_status TEXT DEFAULT 'local_only',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_stripe_customers_stripe_id ON stripe_customers(stripe_customer_id);
CREATE INDEX idx_stripe_customers_user ON stripe_customers(frontend_user_id);

CREATE TABLE stripe_payments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  stripe_payment_intent_id TEXT UNIQUE NOT NULL,
  stripe_customer_id TEXT,
  frontend_user_id UUID REFERENCES frontend_users(id),

  -- Payment details
  amount INTEGER NOT NULL,
  currency TEXT NOT NULL,
  status TEXT NOT NULL,
  payment_method TEXT,

  -- What was purchased
  metadata JSONB NOT NULL,

  -- L4YERCAK3 sync
  l4yercak3_order_id TEXT,
  l4yercak3_invoice_id TEXT,
  sync_status TEXT DEFAULT 'pending_push',
  synced_at TIMESTAMPTZ,

  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ
);

CREATE INDEX idx_stripe_payments_stripe_id ON stripe_payments(stripe_payment_intent_id);
CREATE INDEX idx_stripe_payments_customer ON stripe_payments(stripe_customer_id);
CREATE INDEX idx_stripe_payments_user ON stripe_payments(frontend_user_id);
CREATE INDEX idx_stripe_payments_sync ON stripe_payments(sync_status);

CREATE TABLE stripe_subscriptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  stripe_subscription_id TEXT UNIQUE NOT NULL,
  stripe_customer_id TEXT NOT NULL,
  frontend_user_id UUID REFERENCES frontend_users(id),

  status TEXT NOT NULL,
  price_id TEXT NOT NULL,
  product_id TEXT NOT NULL,

  current_period_start TIMESTAMPTZ NOT NULL,
  current_period_end TIMESTAMPTZ NOT NULL,
  cancel_at_period_end BOOLEAN DEFAULT FALSE,

  l4yercak3_subscription_id TEXT,
  sync_status TEXT DEFAULT 'local_only',

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_stripe_subscriptions_stripe_id ON stripe_subscriptions(stripe_subscription_id);
CREATE INDEX idx_stripe_subscriptions_user ON stripe_subscriptions(frontend_user_id);

-- ============================================
-- SYNC: Job tracking
-- ============================================

CREATE TYPE sync_direction AS ENUM ('push', 'pull', 'bidirectional');
CREATE TYPE sync_job_status AS ENUM ('pending', 'running', 'completed', 'failed');

CREATE TABLE sync_jobs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  entity_type TEXT NOT NULL,
  direction sync_direction NOT NULL,
  status sync_job_status DEFAULT 'pending',

  cursor TEXT,
  processed_count INTEGER DEFAULT 0,
  total_count INTEGER,

  error_message TEXT,
  error_details JSONB,

  started_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ
);

CREATE INDEX idx_sync_jobs_status ON sync_jobs(status);
CREATE INDEX idx_sync_jobs_entity ON sync_jobs(entity_type);

CREATE TABLE sync_conflicts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  object_id UUID REFERENCES objects(id) ON DELETE CASCADE,
  local_version JSONB,
  remote_version JSONB,
  conflict_type TEXT NOT NULL,
  resolved_at TIMESTAMPTZ,
  resolution TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_sync_conflicts_object ON sync_conflicts(object_id);
CREATE INDEX idx_sync_conflicts_unresolved ON sync_conflicts(resolved_at) WHERE resolved_at IS NULL;

-- ============================================
-- TRIGGERS: Auto-update timestamps
-- ============================================

CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER objects_updated_at
  BEFORE UPDATE ON objects
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER frontend_users_updated_at
  BEFORE UPDATE ON frontend_users
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER stripe_subscriptions_updated_at
  BEFORE UPDATE ON stripe_subscriptions
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- ============================================
-- ROW LEVEL SECURITY
-- ============================================

ALTER TABLE objects ENABLE ROW LEVEL SECURITY;
ALTER TABLE object_links ENABLE ROW LEVEL SECURITY;
ALTER TABLE frontend_users ENABLE ROW LEVEL SECURITY;
ALTER TABLE sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE stripe_customers ENABLE ROW LEVEL SECURITY;
ALTER TABLE stripe_payments ENABLE ROW LEVEL SECURITY;
ALTER TABLE stripe_subscriptions ENABLE ROW LEVEL SECURITY;

-- Objects: users can read/write their own organization's objects
CREATE POLICY objects_select ON objects
  FOR SELECT USING (true); -- Adjust based on your auth requirements

CREATE POLICY objects_insert ON objects
  FOR INSERT WITH CHECK (true);

CREATE POLICY objects_update ON objects
  FOR UPDATE USING (true);

CREATE POLICY objects_delete ON objects
  FOR DELETE USING (true);

-- Frontend users: users can read/update their own profile
CREATE POLICY frontend_users_select ON frontend_users
  FOR SELECT USING (true);

CREATE POLICY frontend_users_update ON frontend_users
  FOR UPDATE USING (auth.uid()::text = id::text);

-- Sessions: users can manage their own sessions
CREATE POLICY sessions_all ON sessions
  FOR ALL USING (true);

-- Stripe: users can view their own payment data
CREATE POLICY stripe_customers_select ON stripe_customers
  FOR SELECT USING (true);

CREATE POLICY stripe_payments_select ON stripe_payments
  FOR SELECT USING (true);

CREATE POLICY stripe_subscriptions_select ON stripe_subscriptions
  FOR SELECT USING (true);
`;

    return writeFileWithBackup(outputPath, content, action);
  }

  async generateClient(projectPath, options) {
    const { isTypeScript } = options;

    // Determine output directory
    let outputDir;
    if (fs.existsSync(path.join(projectPath, 'src'))) {
      outputDir = path.join(projectPath, 'src', 'lib', 'supabase');
    } else {
      outputDir = path.join(projectPath, 'lib', 'supabase');
    }

    ensureDir(outputDir);

    const extension = isTypeScript ? 'ts' : 'js';
    const outputPath = path.join(outputDir, `client.${extension}`);

    const action = await checkFileOverwrite(outputPath);
    if (action === 'skip') {
      return null;
    }

    const content = isTypeScript
      ? this.generateTypeScriptClient()
      : this.generateJavaScriptClient();

    return writeFileWithBackup(outputPath, content, action);
  }

  generateTypeScriptClient() {
    return `/**
 * Supabase Client
 * Auto-generated by @l4yercak3/cli
 */

import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables');
}

// Client-side Supabase client
export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);

// Server-side Supabase client (with service role key)
export function createServerClient() {
  const serviceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
  if (!serviceKey) {
    throw new Error('SUPABASE_SERVICE_ROLE_KEY is required for server operations');
  }
  return createClient<Database>(supabaseUrl, serviceKey);
}

// ============ Object Helpers ============

export async function getObjects(type: string, options?: {
  status?: string;
  subtype?: string;
  limit?: number;
}) {
  let query = supabase
    .from('objects')
    .select('*')
    .eq('type', type)
    .is('deleted_at', null)
    .order('updated_at', { ascending: false });

  if (options?.status) {
    query = query.eq('status', options.status);
  }
  if (options?.subtype) {
    query = query.eq('subtype', options.subtype);
  }
  if (options?.limit) {
    query = query.limit(options.limit);
  }

  return query;
}

export async function getObject(id: string) {
  return supabase
    .from('objects')
    .select('*')
    .eq('id', id)
    .single();
}

export async function createObject(data: {
  type: string;
  name: string;
  status: string;
  subtype?: string;
  custom_properties?: Record<string, unknown>;
  organization_id: string;
}) {
  return supabase
    .from('objects')
    .insert({
      ...data,
      sync_status: 'local_only',
      local_version: 1,
    })
    .select()
    .single();
}

export async function updateObject(id: string, data: Partial<{
  name: string;
  status: string;
  subtype: string;
  custom_properties: Record<string, unknown>;
}>) {
  // First get the current object to increment version
  const { data: existing } = await supabase
    .from('objects')
    .select('local_version, sync_status')
    .eq('id', id)
    .single();

  const updates: Record<string, unknown> = {
    ...data,
    local_version: (existing?.local_version || 0) + 1,
  };

  // Mark as pending push if previously synced
  if (existing?.sync_status === 'synced') {
    updates.sync_status = 'pending_push';
  }

  return supabase
    .from('objects')
    .update(updates)
    .eq('id', id)
    .select()
    .single();
}

export async function deleteObject(id: string) {
  // Soft delete
  return supabase
    .from('objects')
    .update({
      deleted_at: new Date().toISOString(),
      sync_status: 'pending_push',
    })
    .eq('id', id);
}

// ============ User Helpers ============

export async function getUserByEmail(email: string) {
  return supabase
    .from('frontend_users')
    .select('*')
    .eq('email', email)
    .single();
}

export async function createUser(data: {
  email: string;
  name?: string;
  first_name?: string;
  last_name?: string;
  organization_id: string;
  role?: string;
}) {
  return supabase
    .from('frontend_users')
    .insert({
      ...data,
      email_verified: false,
      oauth_accounts: [],
      role: data.role || 'user',
      sync_status: 'pending_push',
    })
    .select()
    .single();
}

// ============ Sync Helpers ============

export async function getPendingSync(direction: 'push' | 'pull') {
  const status = direction === 'push' ? 'pending_push' : 'pending_pull';
  return supabase
    .from('objects')
    .select('*')
    .eq('sync_status', status);
}

export async function markSynced(id: string, l4yercak3Id: string) {
  return supabase
    .from('objects')
    .update({
      l4yercak3_id: l4yercak3Id,
      sync_status: 'synced',
      synced_at: new Date().toISOString(),
    })
    .eq('id', id);
}
`;
  }

  generateJavaScriptClient() {
    return `/**
 * Supabase Client
 * Auto-generated by @l4yercak3/cli
 */

const { createClient } = require('@supabase/supabase-js');

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables');
}

// Client-side Supabase client
const supabase = createClient(supabaseUrl, supabaseAnonKey);

// Server-side Supabase client
function createServerClient() {
  const serviceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
  if (!serviceKey) {
    throw new Error('SUPABASE_SERVICE_ROLE_KEY is required for server operations');
  }
  return createClient(supabaseUrl, serviceKey);
}

// ============ Object Helpers ============

async function getObjects(type, options = {}) {
  let query = supabase
    .from('objects')
    .select('*')
    .eq('type', type)
    .is('deleted_at', null)
    .order('updated_at', { ascending: false });

  if (options.status) {
    query = query.eq('status', options.status);
  }
  if (options.subtype) {
    query = query.eq('subtype', options.subtype);
  }
  if (options.limit) {
    query = query.limit(options.limit);
  }

  return query;
}

async function getObject(id) {
  return supabase
    .from('objects')
    .select('*')
    .eq('id', id)
    .single();
}

async function createObject(data) {
  return supabase
    .from('objects')
    .insert({
      ...data,
      sync_status: 'local_only',
      local_version: 1,
    })
    .select()
    .single();
}

async function updateObject(id, data) {
  const { data: existing } = await supabase
    .from('objects')
    .select('local_version, sync_status')
    .eq('id', id)
    .single();

  const updates = {
    ...data,
    local_version: (existing?.local_version || 0) + 1,
  };

  if (existing?.sync_status === 'synced') {
    updates.sync_status = 'pending_push';
  }

  return supabase
    .from('objects')
    .update(updates)
    .eq('id', id)
    .select()
    .single();
}

async function deleteObject(id) {
  return supabase
    .from('objects')
    .update({
      deleted_at: new Date().toISOString(),
      sync_status: 'pending_push',
    })
    .eq('id', id);
}

// ============ User Helpers ============

async function getUserByEmail(email) {
  return supabase
    .from('frontend_users')
    .select('*')
    .eq('email', email)
    .single();
}

async function createUser(data) {
  return supabase
    .from('frontend_users')
    .insert({
      ...data,
      email_verified: false,
      oauth_accounts: [],
      role: data.role || 'user',
      sync_status: 'pending_push',
    })
    .select()
    .single();
}

// ============ Sync Helpers ============

async function getPendingSync(direction) {
  const status = direction === 'push' ? 'pending_push' : 'pending_pull';
  return supabase
    .from('objects')
    .select('*')
    .eq('sync_status', status);
}

async function markSynced(id, l4yercak3Id) {
  return supabase
    .from('objects')
    .update({
      l4yercak3_id: l4yercak3Id,
      sync_status: 'synced',
      synced_at: new Date().toISOString(),
    })
    .eq('id', id);
}

module.exports = {
  supabase,
  createServerClient,
  getObjects,
  getObject,
  createObject,
  updateObject,
  deleteObject,
  getUserByEmail,
  createUser,
  getPendingSync,
  markSynced,
};
`;
  }

  async generateTypes(projectPath) {
    // Determine output directory
    let outputDir;
    if (fs.existsSync(path.join(projectPath, 'src'))) {
      outputDir = path.join(projectPath, 'src', 'lib', 'supabase');
    } else {
      outputDir = path.join(projectPath, 'lib', 'supabase');
    }

    ensureDir(outputDir);

    const outputPath = path.join(outputDir, 'types.ts');

    const action = await checkFileOverwrite(outputPath);
    if (action === 'skip') {
      return null;
    }

    const content = `/**
 * Supabase Database Types
 * Auto-generated by @l4yercak3/cli
 *
 * Note: For full type safety, generate types from your database using:
 * npx supabase gen types typescript --project-id YOUR_PROJECT_ID > src/lib/supabase/types.ts
 */

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[];

export type SyncStatus =
  | 'synced'
  | 'pending_push'
  | 'pending_pull'
  | 'conflict'
  | 'local_only';

export interface Database {
  public: {
    Tables: {
      objects: {
        Row: {
          id: string;
          l4yercak3_id: string | null;
          organization_id: string;
          type: string;
          subtype: string | null;
          name: string;
          status: string;
          custom_properties: Json;
          sync_status: SyncStatus;
          synced_at: string | null;
          local_version: number;
          remote_version: number | null;
          created_at: string;
          updated_at: string;
          deleted_at: string | null;
        };
        Insert: {
          id?: string;
          l4yercak3_id?: string | null;
          organization_id: string;
          type: string;
          subtype?: string | null;
          name: string;
          status: string;
          custom_properties?: Json;
          sync_status?: SyncStatus;
          synced_at?: string | null;
          local_version?: number;
          remote_version?: number | null;
          created_at?: string;
          updated_at?: string;
          deleted_at?: string | null;
        };
        Update: {
          id?: string;
          l4yercak3_id?: string | null;
          organization_id?: string;
          type?: string;
          subtype?: string | null;
          name?: string;
          status?: string;
          custom_properties?: Json;
          sync_status?: SyncStatus;
          synced_at?: string | null;
          local_version?: number;
          remote_version?: number | null;
          created_at?: string;
          updated_at?: string;
          deleted_at?: string | null;
        };
      };
      object_links: {
        Row: {
          id: string;
          l4yercak3_id: string | null;
          from_object_id: string;
          to_object_id: string;
          link_type: string;
          metadata: Json | null;
          sync_status: string;
          created_at: string;
        };
        Insert: {
          id?: string;
          l4yercak3_id?: string | null;
          from_object_id: string;
          to_object_id: string;
          link_type: string;
          metadata?: Json | null;
          sync_status?: string;
          created_at?: string;
        };
        Update: {
          id?: string;
          l4yercak3_id?: string | null;
          from_object_id?: string;
          to_object_id?: string;
          link_type?: string;
          metadata?: Json | null;
          sync_status?: string;
          created_at?: string;
        };
      };
      frontend_users: {
        Row: {
          id: string;
          l4yercak3_contact_id: string | null;
          l4yercak3_frontend_user_id: string | null;
          organization_id: string;
          email: string;
          email_verified: boolean;
          name: string | null;
          first_name: string | null;
          last_name: string | null;
          image: string | null;
          phone: string | null;
          password_hash: string | null;
          oauth_accounts: Json;
          role: string;
          preferences: Json;
          sync_status: string;
          synced_at: string | null;
          created_at: string;
          updated_at: string;
          last_login_at: string | null;
        };
        Insert: {
          id?: string;
          l4yercak3_contact_id?: string | null;
          l4yercak3_frontend_user_id?: string | null;
          organization_id: string;
          email: string;
          email_verified?: boolean;
          name?: string | null;
          first_name?: string | null;
          last_name?: string | null;
          image?: string | null;
          phone?: string | null;
          password_hash?: string | null;
          oauth_accounts?: Json;
          role?: string;
          preferences?: Json;
          sync_status?: string;
          synced_at?: string | null;
          created_at?: string;
          updated_at?: string;
          last_login_at?: string | null;
        };
        Update: {
          id?: string;
          l4yercak3_contact_id?: string | null;
          l4yercak3_frontend_user_id?: string | null;
          organization_id?: string;
          email?: string;
          email_verified?: boolean;
          name?: string | null;
          first_name?: string | null;
          last_name?: string | null;
          image?: string | null;
          phone?: string | null;
          password_hash?: string | null;
          oauth_accounts?: Json;
          role?: string;
          preferences?: Json;
          sync_status?: string;
          synced_at?: string | null;
          created_at?: string;
          updated_at?: string;
          last_login_at?: string | null;
        };
      };
      sessions: {
        Row: {
          id: string;
          user_id: string;
          session_token: string;
          expires_at: string;
          user_agent: string | null;
          ip_address: string | null;
          created_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          session_token: string;
          expires_at: string;
          user_agent?: string | null;
          ip_address?: string | null;
          created_at?: string;
        };
        Update: {
          id?: string;
          user_id?: string;
          session_token?: string;
          expires_at?: string;
          user_agent?: string | null;
          ip_address?: string | null;
          created_at?: string;
        };
      };
      stripe_customers: {
        Row: {
          id: string;
          frontend_user_id: string;
          stripe_customer_id: string;
          l4yercak3_contact_id: string | null;
          email: string;
          name: string | null;
          default_payment_method_id: string | null;
          sync_status: string;
          created_at: string;
        };
        Insert: {
          id?: string;
          frontend_user_id: string;
          stripe_customer_id: string;
          l4yercak3_contact_id?: string | null;
          email: string;
          name?: string | null;
          default_payment_method_id?: string | null;
          sync_status?: string;
          created_at?: string;
        };
        Update: {
          id?: string;
          frontend_user_id?: string;
          stripe_customer_id?: string;
          l4yercak3_contact_id?: string | null;
          email?: string;
          name?: string | null;
          default_payment_method_id?: string | null;
          sync_status?: string;
          created_at?: string;
        };
      };
      stripe_payments: {
        Row: {
          id: string;
          stripe_payment_intent_id: string;
          stripe_customer_id: string | null;
          frontend_user_id: string | null;
          amount: number;
          currency: string;
          status: string;
          payment_method: string | null;
          metadata: Json;
          l4yercak3_order_id: string | null;
          l4yercak3_invoice_id: string | null;
          sync_status: string;
          synced_at: string | null;
          created_at: string;
          completed_at: string | null;
        };
        Insert: {
          id?: string;
          stripe_payment_intent_id: string;
          stripe_customer_id?: string | null;
          frontend_user_id?: string | null;
          amount: number;
          currency: string;
          status: string;
          payment_method?: string | null;
          metadata: Json;
          l4yercak3_order_id?: string | null;
          l4yercak3_invoice_id?: string | null;
          sync_status?: string;
          synced_at?: string | null;
          created_at?: string;
          completed_at?: string | null;
        };
        Update: {
          id?: string;
          stripe_payment_intent_id?: string;
          stripe_customer_id?: string | null;
          frontend_user_id?: string | null;
          amount?: number;
          currency?: string;
          status?: string;
          payment_method?: string | null;
          metadata?: Json;
          l4yercak3_order_id?: string | null;
          l4yercak3_invoice_id?: string | null;
          sync_status?: string;
          synced_at?: string | null;
          created_at?: string;
          completed_at?: string | null;
        };
      };
    };
  };
}
`;

    return writeFileWithBackup(outputPath, content, action);
  }

  async generateMiddleware(projectPath, options) {
    const { isTypeScript } = options;

    const extension = isTypeScript ? 'ts' : 'js';
    const outputPath = path.join(projectPath, `middleware.${extension}`);

    const action = await checkFileOverwrite(outputPath);
    if (action === 'skip') {
      return null;
    }

    const content = isTypeScript
      ? `/**
 * Supabase Auth Middleware
 * Auto-generated by @l4yercak3/cli
 */

import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs';
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export async function middleware(req: NextRequest) {
  const res = NextResponse.next();
  const supabase = createMiddlewareClient({ req, res });
  await supabase.auth.getSession();
  return res;
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|public).*)',
  ],
};
`
      : `/**
 * Supabase Auth Middleware
 * Auto-generated by @l4yercak3/cli
 */

const { createMiddlewareClient } = require('@supabase/auth-helpers-nextjs');
const { NextResponse } = require('next/server');

async function middleware(req) {
  const res = NextResponse.next();
  const supabase = createMiddlewareClient({ req, res });
  await supabase.auth.getSession();
  return res;
}

const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|public).*)',
  ],
};

module.exports = { middleware, config };
`;

    return writeFileWithBackup(outputPath, content, action);
  }
}

module.exports = new SupabaseGenerator();
