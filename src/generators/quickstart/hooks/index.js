/**
 * React Hooks Generator
 * Generates React Query hooks for L4YERCAK3 data fetching
 */

const fs = require('fs');
const path = require('path');
const { ensureDir, writeFileWithBackup, checkFileOverwrite } = require('../../../utils/file-utils');

class HooksGenerator {
  /**
   * Generate React hooks based on selected features
   * @param {Object} options - Generation options
   * @returns {Promise<Object>} - Generated file paths
   */
  /**
   * Check if framework is Expo/React Native
   */
  isMobileFramework(frameworkType) {
    return ['expo', 'react-native'].includes(frameworkType);
  }

  async generate(options) {
    const { projectPath, features = [], frameworkType } = options;
    const isMobile = this.isMobileFramework(frameworkType);

    const results = {};

    // Determine output directory based on framework
    let outputDir;
    if (isMobile) {
      // Expo typically uses src/lib or just lib
      if (fs.existsSync(path.join(projectPath, 'src'))) {
        outputDir = path.join(projectPath, 'src', 'lib', 'l4yercak3', 'hooks');
      } else {
        outputDir = path.join(projectPath, 'lib', 'l4yercak3', 'hooks');
      }
    } else {
      // Next.js uses src/lib
      if (fs.existsSync(path.join(projectPath, 'src'))) {
        outputDir = path.join(projectPath, 'src', 'lib', 'l4yercak3', 'hooks');
      } else {
        outputDir = path.join(projectPath, 'lib', 'l4yercak3', 'hooks');
      }
    }

    ensureDir(outputDir);

    // Generate hooks based on features
    if (features.includes('crm')) {
      results.contacts = await this.generateContactsHook(outputDir, options);
      results.organizations = await this.generateOrganizationsHook(outputDir, options);
    }

    if (features.includes('events')) {
      results.events = await this.generateEventsHook(outputDir, options);
    }

    if (features.includes('forms')) {
      results.forms = await this.generateFormsHook(outputDir, options);
    }

    if (features.includes('products') || features.includes('checkout')) {
      results.products = await this.generateProductsHook(outputDir, options);
    }

    if (features.includes('invoicing')) {
      results.invoices = await this.generateInvoicesHook(outputDir, options);
    }

    // Generate index file
    results.index = await this.generateIndex(outputDir, options, Object.keys(results));

    return results;
  }

  async generateContactsHook(outputDir, options) {
    const { isTypeScript, selectedDatabase } = options;
    const extension = isTypeScript ? 'ts' : 'js';
    const outputPath = path.join(outputDir, `use-contacts.${extension}`);

    const action = await checkFileOverwrite(outputPath);
    if (action === 'skip') {
      return null;
    }

    const content = isTypeScript
      ? this.generateContactsHookTS(selectedDatabase)
      : this.generateContactsHookJS(selectedDatabase);

    return writeFileWithBackup(outputPath, content, action);
  }

  generateContactsHookTS(database) {
    const isConvex = database === 'convex';

    return `/**
 * Contacts Hooks
 * Auto-generated by @l4yercak3/cli
 */

${isConvex ? `import { useQuery, useMutation } from "convex/react";
import { api } from "@/convex/_generated/api";
import type { Id } from "@/convex/_generated/dataModel";` : `import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { getL4yercak3Client } from '../client';
import type { Contact, ContactCreateInput, ContactUpdateInput } from '../types';`}

${isConvex ? `
// ============ Convex Hooks ============

export function useContacts(options?: { status?: string; subtype?: string; limit?: number }) {
  return useQuery(api.objects.list, {
    type: "contact",
    status: options?.status,
    subtype: options?.subtype,
    limit: options?.limit,
  });
}

export function useContact(id: Id<"objects"> | undefined) {
  return useQuery(api.objects.get, id ? { id } : "skip");
}

export function useCreateContact() {
  return useMutation(api.objects.create);
}

export function useUpdateContact() {
  return useMutation(api.objects.update);
}

export function useDeleteContact() {
  return useMutation(api.objects.remove);
}

export function useSearchContacts(searchTerm: string) {
  return useQuery(
    api.objects.search,
    searchTerm ? { type: "contact", searchTerm } : "skip"
  );
}
` : `
// ============ React Query Hooks ============

const client = getL4yercak3Client();

export function useContacts(options?: {
  status?: 'active' | 'inactive' | 'archived';
  subtype?: 'customer' | 'lead' | 'prospect' | 'partner';
  search?: string;
  limit?: number;
}) {
  return useQuery({
    queryKey: ['contacts', options],
    queryFn: () => client.listContacts(options),
  });
}

export function useContact(id: string | undefined, options?: {
  includeActivities?: boolean;
  includeNotes?: boolean;
}) {
  return useQuery({
    queryKey: ['contact', id, options],
    queryFn: () => client.getContact(id!, options),
    enabled: !!id,
  });
}

export function useCreateContact() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: ContactCreateInput) => client.createContact(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['contacts'] });
    },
  });
}

export function useUpdateContact() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: ContactUpdateInput }) =>
      client.updateContact(id, data),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['contacts'] });
      queryClient.invalidateQueries({ queryKey: ['contact', variables.id] });
    },
  });
}

export function useDeleteContact() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) => client.deleteContact(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['contacts'] });
    },
  });
}

export function useAddTagsToContact() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, tags }: { id: string; tags: string[] }) =>
      client.addTagsToContact(id, tags),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['contact', variables.id] });
    },
  });
}
`}`;
  }

  generateContactsHookJS(database) {
    const isConvex = database === 'convex';

    return `/**
 * Contacts Hooks
 * Auto-generated by @l4yercak3/cli
 */

${isConvex ? `const { useQuery, useMutation } = require("convex/react");
const { api } = require("@/convex/_generated/api");` : `const { useQuery, useMutation, useQueryClient } = require('@tanstack/react-query');
const { getL4yercak3Client } = require('../client');`}

${isConvex ? `
// ============ Convex Hooks ============

function useContacts(options = {}) {
  return useQuery(api.objects.list, {
    type: "contact",
    status: options.status,
    subtype: options.subtype,
    limit: options.limit,
  });
}

function useContact(id) {
  return useQuery(api.objects.get, id ? { id } : "skip");
}

function useCreateContact() {
  return useMutation(api.objects.create);
}

function useUpdateContact() {
  return useMutation(api.objects.update);
}

function useDeleteContact() {
  return useMutation(api.objects.remove);
}

function useSearchContacts(searchTerm) {
  return useQuery(
    api.objects.search,
    searchTerm ? { type: "contact", searchTerm } : "skip"
  );
}

module.exports = {
  useContacts,
  useContact,
  useCreateContact,
  useUpdateContact,
  useDeleteContact,
  useSearchContacts,
};
` : `
// ============ React Query Hooks ============

const client = getL4yercak3Client();

function useContacts(options = {}) {
  return useQuery({
    queryKey: ['contacts', options],
    queryFn: () => client.listContacts(options),
  });
}

function useContact(id, options = {}) {
  return useQuery({
    queryKey: ['contact', id, options],
    queryFn: () => client.getContact(id, options),
    enabled: !!id,
  });
}

function useCreateContact() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data) => client.createContact(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['contacts'] });
    },
  });
}

function useUpdateContact() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }) => client.updateContact(id, data),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['contacts'] });
      queryClient.invalidateQueries({ queryKey: ['contact', variables.id] });
    },
  });
}

function useDeleteContact() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => client.deleteContact(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['contacts'] });
    },
  });
}

module.exports = {
  useContacts,
  useContact,
  useCreateContact,
  useUpdateContact,
  useDeleteContact,
};
`}`;
  }

  async generateOrganizationsHook(outputDir, options) {
    const { isTypeScript } = options;
    const extension = isTypeScript ? 'ts' : 'js';
    const outputPath = path.join(outputDir, `use-organizations.${extension}`);

    const action = await checkFileOverwrite(outputPath);
    if (action === 'skip') {
      return null;
    }

    const content = isTypeScript
      ? `/**
 * Organizations Hooks
 * Auto-generated by @l4yercak3/cli
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { getL4yercak3Client } from '../client';
import type { Organization, OrganizationCreateInput } from '../types';

const client = getL4yercak3Client();

export function useOrganizations(options?: {
  subtype?: 'customer' | 'prospect' | 'partner' | 'vendor';
  search?: string;
  limit?: number;
}) {
  return useQuery({
    queryKey: ['organizations', options],
    queryFn: () => client.listOrganizations(options),
  });
}

export function useOrganization(id: string | undefined, options?: {
  includeContacts?: boolean;
}) {
  return useQuery({
    queryKey: ['organization', id, options],
    queryFn: () => client.getOrganization(id!, options),
    enabled: !!id,
  });
}

export function useCreateOrganization() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: OrganizationCreateInput) => client.createOrganization(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['organizations'] });
    },
  });
}
`
      : `/**
 * Organizations Hooks
 * Auto-generated by @l4yercak3/cli
 */

const { useQuery, useMutation, useQueryClient } = require('@tanstack/react-query');
const { getL4yercak3Client } = require('../client');

const client = getL4yercak3Client();

function useOrganizations(options = {}) {
  return useQuery({
    queryKey: ['organizations', options],
    queryFn: () => client.listOrganizations(options),
  });
}

function useOrganization(id, options = {}) {
  return useQuery({
    queryKey: ['organization', id, options],
    queryFn: () => client.getOrganization(id, options),
    enabled: !!id,
  });
}

function useCreateOrganization() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data) => client.createOrganization(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['organizations'] });
    },
  });
}

module.exports = {
  useOrganizations,
  useOrganization,
  useCreateOrganization,
};
`;

    return writeFileWithBackup(outputPath, content, action);
  }

  async generateEventsHook(outputDir, options) {
    const { isTypeScript } = options;
    const extension = isTypeScript ? 'ts' : 'js';
    const outputPath = path.join(outputDir, `use-events.${extension}`);

    const action = await checkFileOverwrite(outputPath);
    if (action === 'skip') {
      return null;
    }

    const content = isTypeScript
      ? `/**
 * Events Hooks
 * Auto-generated by @l4yercak3/cli
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { getL4yercak3Client } from '../client';
import type { Event, EventCreateInput, Attendee } from '../types';

const client = getL4yercak3Client();

export function useEvents(options?: {
  status?: 'draft' | 'published' | 'cancelled' | 'completed';
  fromDate?: string;
  toDate?: string;
  limit?: number;
}) {
  return useQuery({
    queryKey: ['events', options],
    queryFn: () => client.listEvents(options),
  });
}

export function useEvent(id: string | undefined, options?: {
  includeProducts?: boolean;
  includeSponsors?: boolean;
  includeForms?: boolean;
}) {
  return useQuery({
    queryKey: ['event', id, options],
    queryFn: () => client.getEvent(id!, options),
    enabled: !!id,
  });
}

export function useEventAttendees(eventId: string | undefined, options?: {
  status?: 'registered' | 'checked_in' | 'cancelled' | 'no_show';
  limit?: number;
}) {
  return useQuery({
    queryKey: ['eventAttendees', eventId, options],
    queryFn: () => client.getEventAttendees(eventId!, options),
    enabled: !!eventId,
  });
}

export function useCreateEvent() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: EventCreateInput) => client.createEvent(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['events'] });
    },
  });
}

export function useCheckInAttendee() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ eventId, attendeeId }: { eventId: string; attendeeId: string }) =>
      client.checkInAttendee(eventId, attendeeId),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['eventAttendees', variables.eventId] });
    },
  });
}
`
      : `/**
 * Events Hooks
 * Auto-generated by @l4yercak3/cli
 */

const { useQuery, useMutation, useQueryClient } = require('@tanstack/react-query');
const { getL4yercak3Client } = require('../client');

const client = getL4yercak3Client();

function useEvents(options = {}) {
  return useQuery({
    queryKey: ['events', options],
    queryFn: () => client.listEvents(options),
  });
}

function useEvent(id, options = {}) {
  return useQuery({
    queryKey: ['event', id, options],
    queryFn: () => client.getEvent(id, options),
    enabled: !!id,
  });
}

function useEventAttendees(eventId, options = {}) {
  return useQuery({
    queryKey: ['eventAttendees', eventId, options],
    queryFn: () => client.getEventAttendees(eventId, options),
    enabled: !!eventId,
  });
}

function useCreateEvent() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data) => client.createEvent(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['events'] });
    },
  });
}

function useCheckInAttendee() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ eventId, attendeeId }) => client.checkInAttendee(eventId, attendeeId),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['eventAttendees', variables.eventId] });
    },
  });
}

module.exports = {
  useEvents,
  useEvent,
  useEventAttendees,
  useCreateEvent,
  useCheckInAttendee,
};
`;

    return writeFileWithBackup(outputPath, content, action);
  }

  async generateFormsHook(outputDir, options) {
    const { isTypeScript } = options;
    const extension = isTypeScript ? 'ts' : 'js';
    const outputPath = path.join(outputDir, `use-forms.${extension}`);

    const action = await checkFileOverwrite(outputPath);
    if (action === 'skip') {
      return null;
    }

    const content = isTypeScript
      ? `/**
 * Forms Hooks
 * Auto-generated by @l4yercak3/cli
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { getL4yercak3Client } from '../client';
import type { Form, FormSubmission } from '../types';

const client = getL4yercak3Client();

export function useForms(options?: {
  status?: 'draft' | 'published' | 'closed';
  eventId?: string;
  subtype?: 'registration' | 'survey' | 'application' | 'feedback' | 'contact';
  limit?: number;
}) {
  return useQuery({
    queryKey: ['forms', options],
    queryFn: () => client.listForms(options),
  });
}

export function useForm(id: string | undefined) {
  return useQuery({
    queryKey: ['form', id],
    queryFn: () => client.getForm(id!),
    enabled: !!id,
  });
}

export function useFormResponses(formId: string | undefined, options?: {
  status?: 'submitted' | 'reviewed' | 'approved' | 'rejected';
  limit?: number;
}) {
  return useQuery({
    queryKey: ['formResponses', formId, options],
    queryFn: () => client.getFormResponses(formId!, options),
    enabled: !!formId,
  });
}

export function useSubmitForm() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ formId, data }: { formId: string; data: Record<string, unknown> }) =>
      client.submitForm(formId, data),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['formResponses', variables.formId] });
    },
  });
}
`
      : `/**
 * Forms Hooks
 * Auto-generated by @l4yercak3/cli
 */

const { useQuery, useMutation, useQueryClient } = require('@tanstack/react-query');
const { getL4yercak3Client } = require('../client');

const client = getL4yercak3Client();

function useForms(options = {}) {
  return useQuery({
    queryKey: ['forms', options],
    queryFn: () => client.listForms(options),
  });
}

function useForm(id) {
  return useQuery({
    queryKey: ['form', id],
    queryFn: () => client.getForm(id),
    enabled: !!id,
  });
}

function useFormResponses(formId, options = {}) {
  return useQuery({
    queryKey: ['formResponses', formId, options],
    queryFn: () => client.getFormResponses(formId, options),
    enabled: !!formId,
  });
}

function useSubmitForm() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ formId, data }) => client.submitForm(formId, data),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['formResponses', variables.formId] });
    },
  });
}

module.exports = {
  useForms,
  useForm,
  useFormResponses,
  useSubmitForm,
};
`;

    return writeFileWithBackup(outputPath, content, action);
  }

  async generateProductsHook(outputDir, options) {
    const { isTypeScript } = options;
    const extension = isTypeScript ? 'ts' : 'js';
    const outputPath = path.join(outputDir, `use-products.${extension}`);

    const action = await checkFileOverwrite(outputPath);
    if (action === 'skip') {
      return null;
    }

    const content = isTypeScript
      ? `/**
 * Products & Checkout Hooks
 * Auto-generated by @l4yercak3/cli
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { getL4yercak3Client } from '../client';
import type { Product, Order } from '../types';

const client = getL4yercak3Client();

export function useProducts(options?: {
  eventId?: string;
  status?: 'active' | 'sold_out' | 'hidden';
  category?: string;
  limit?: number;
}) {
  return useQuery({
    queryKey: ['products', options],
    queryFn: () => client.listProducts(options),
  });
}

export function useProduct(id: string | undefined) {
  return useQuery({
    queryKey: ['product', id],
    queryFn: () => client.getProduct(id!),
    enabled: !!id,
  });
}

export function useOrders(options?: {
  contactId?: string;
  status?: 'pending' | 'paid' | 'refunded' | 'cancelled';
  limit?: number;
}) {
  return useQuery({
    queryKey: ['orders', options],
    queryFn: () => client.listOrders(options),
  });
}

export function useOrder(id: string | undefined) {
  return useQuery({
    queryKey: ['order', id],
    queryFn: () => client.getOrder(id!),
    enabled: !!id,
  });
}

export function useCreateCheckoutSession() {
  return useMutation({
    mutationFn: (data: {
      items: Array<{ productId: string; quantity: number }>;
      contactId?: string;
      email?: string;
      successUrl: string;
      cancelUrl: string;
    }) => client.createCheckoutSession(data),
  });
}

export function useCheckoutSession(sessionId: string | undefined) {
  return useQuery({
    queryKey: ['checkoutSession', sessionId],
    queryFn: () => client.getCheckoutSession(sessionId!),
    enabled: !!sessionId,
  });
}
`
      : `/**
 * Products & Checkout Hooks
 * Auto-generated by @l4yercak3/cli
 */

const { useQuery, useMutation } = require('@tanstack/react-query');
const { getL4yercak3Client } = require('../client');

const client = getL4yercak3Client();

function useProducts(options = {}) {
  return useQuery({
    queryKey: ['products', options],
    queryFn: () => client.listProducts(options),
  });
}

function useProduct(id) {
  return useQuery({
    queryKey: ['product', id],
    queryFn: () => client.getProduct(id),
    enabled: !!id,
  });
}

function useOrders(options = {}) {
  return useQuery({
    queryKey: ['orders', options],
    queryFn: () => client.listOrders(options),
  });
}

function useOrder(id) {
  return useQuery({
    queryKey: ['order', id],
    queryFn: () => client.getOrder(id),
    enabled: !!id,
  });
}

function useCreateCheckoutSession() {
  return useMutation({
    mutationFn: (data) => client.createCheckoutSession(data),
  });
}

function useCheckoutSession(sessionId) {
  return useQuery({
    queryKey: ['checkoutSession', sessionId],
    queryFn: () => client.getCheckoutSession(sessionId),
    enabled: !!sessionId,
  });
}

module.exports = {
  useProducts,
  useProduct,
  useOrders,
  useOrder,
  useCreateCheckoutSession,
  useCheckoutSession,
};
`;

    return writeFileWithBackup(outputPath, content, action);
  }

  async generateInvoicesHook(outputDir, options) {
    const { isTypeScript } = options;
    const extension = isTypeScript ? 'ts' : 'js';
    const outputPath = path.join(outputDir, `use-invoices.${extension}`);

    const action = await checkFileOverwrite(outputPath);
    if (action === 'skip') {
      return null;
    }

    const content = isTypeScript
      ? `/**
 * Invoices Hooks
 * Auto-generated by @l4yercak3/cli
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { getL4yercak3Client } from '../client';
import type { Invoice, InvoiceCreateInput } from '../types';

const client = getL4yercak3Client();

export function useInvoices(options?: {
  contactId?: string;
  organizationId?: string;
  status?: 'draft' | 'sent' | 'paid' | 'overdue' | 'cancelled';
  type?: 'b2b' | 'b2c';
  limit?: number;
}) {
  return useQuery({
    queryKey: ['invoices', options],
    queryFn: () => client.listInvoices(options),
  });
}

export function useInvoice(id: string | undefined) {
  return useQuery({
    queryKey: ['invoice', id],
    queryFn: () => client.getInvoice(id!),
    enabled: !!id,
  });
}

export function useCreateInvoice() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: InvoiceCreateInput) => client.createInvoice(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['invoices'] });
    },
  });
}

export function useSendInvoice() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, options }: { id: string; options?: { emailTo?: string; message?: string } }) =>
      client.sendInvoice(id, options),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['invoice', variables.id] });
      queryClient.invalidateQueries({ queryKey: ['invoices'] });
    },
  });
}

export function useMarkInvoicePaid() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data?: { paidAt?: string; paymentMethod?: string } }) =>
      client.markInvoicePaid(id, data),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['invoice', variables.id] });
      queryClient.invalidateQueries({ queryKey: ['invoices'] });
    },
  });
}

export function useInvoicePdf(id: string | undefined) {
  return useQuery({
    queryKey: ['invoicePdf', id],
    queryFn: () => client.getInvoicePdf(id!),
    enabled: !!id,
  });
}
`
      : `/**
 * Invoices Hooks
 * Auto-generated by @l4yercak3/cli
 */

const { useQuery, useMutation, useQueryClient } = require('@tanstack/react-query');
const { getL4yercak3Client } = require('../client');

const client = getL4yercak3Client();

function useInvoices(options = {}) {
  return useQuery({
    queryKey: ['invoices', options],
    queryFn: () => client.listInvoices(options),
  });
}

function useInvoice(id) {
  return useQuery({
    queryKey: ['invoice', id],
    queryFn: () => client.getInvoice(id),
    enabled: !!id,
  });
}

function useCreateInvoice() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data) => client.createInvoice(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['invoices'] });
    },
  });
}

function useSendInvoice() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, options }) => client.sendInvoice(id, options),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['invoice', variables.id] });
      queryClient.invalidateQueries({ queryKey: ['invoices'] });
    },
  });
}

function useMarkInvoicePaid() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }) => client.markInvoicePaid(id, data),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['invoice', variables.id] });
      queryClient.invalidateQueries({ queryKey: ['invoices'] });
    },
  });
}

module.exports = {
  useInvoices,
  useInvoice,
  useCreateInvoice,
  useSendInvoice,
  useMarkInvoicePaid,
};
`;

    return writeFileWithBackup(outputPath, content, action);
  }

  async generateIndex(outputDir, options, generatedHooks) {
    const { isTypeScript } = options;
    const extension = isTypeScript ? 'ts' : 'js';
    const outputPath = path.join(outputDir, `index.${extension}`);

    const action = await checkFileOverwrite(outputPath);
    if (action === 'skip') {
      return null;
    }

    const exports = [];
    if (generatedHooks.includes('contacts')) {
      exports.push(isTypeScript ? "export * from './use-contacts';" : "...require('./use-contacts'),");
    }
    if (generatedHooks.includes('organizations')) {
      exports.push(isTypeScript ? "export * from './use-organizations';" : "...require('./use-organizations'),");
    }
    if (generatedHooks.includes('events')) {
      exports.push(isTypeScript ? "export * from './use-events';" : "...require('./use-events'),");
    }
    if (generatedHooks.includes('forms')) {
      exports.push(isTypeScript ? "export * from './use-forms';" : "...require('./use-forms'),");
    }
    if (generatedHooks.includes('products')) {
      exports.push(isTypeScript ? "export * from './use-products';" : "...require('./use-products'),");
    }
    if (generatedHooks.includes('invoices')) {
      exports.push(isTypeScript ? "export * from './use-invoices';" : "...require('./use-invoices'),");
    }

    const content = isTypeScript
      ? `/**
 * L4YERCAK3 React Hooks
 * Auto-generated by @l4yercak3/cli
 */

${exports.join('\n')}
`
      : `/**
 * L4YERCAK3 React Hooks
 * Auto-generated by @l4yercak3/cli
 */

module.exports = {
  ${exports.join('\n  ')}
};
`;

    return writeFileWithBackup(outputPath, content, action);
  }
}

module.exports = new HooksGenerator();
