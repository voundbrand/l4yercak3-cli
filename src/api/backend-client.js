/**
 * Backend API Client
 * Handles communication with L4YERCAK3 backend API
 */

const crypto = require('crypto');
const fetch = require('node-fetch');
const configManager = require('../config/config-manager');

class BackendClient {
  constructor() {
    this.baseUrl = configManager.getBackendUrl();
  }

  /**
   * Generate a cryptographically secure state token for CSRF protection
   */
  generateState() {
    return crypto.randomBytes(32).toString('hex');
  }

  /**
   * Get headers for API requests
   */
  getHeaders() {
    const session = configManager.getSession();
    const headers = {
      'Content-Type': 'application/json',
    };

    if (session && session.token) {
      headers['Authorization'] = `Bearer ${session.token}`;
    }

    return headers;
  }

  /**
   * Make API request
   * Returns response data with error details preserved for specific handling
   */
  async request(method, endpoint, data = null) {
    const url = `${this.baseUrl}${endpoint}`;
    const options = {
      method,
      headers: this.getHeaders(),
    };

    if (data && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {
      options.body = JSON.stringify(data);
    }

    try {
      const response = await fetch(url, options);
      const responseData = await response.json();

      if (!response.ok) {
        // Create error with additional details from backend
        const error = new Error(responseData.message || responseData.error || `API request failed: ${response.status}`);
        error.code = responseData.code || 'UNKNOWN_ERROR';
        error.suggestion = responseData.suggestion || null;
        error.upgradeUrl = responseData.upgradeUrl || null;
        error.upgradeCommand = responseData.upgradeCommand || null;
        error.status = response.status;
        throw error;
      }

      return responseData;
    } catch (error) {
      if (error.message.includes('fetch')) {
        throw new Error(`Network error: Could not connect to backend at ${this.baseUrl}`);
      }
      throw error;
    }
  }

  /**
   * Validate CLI session
   */
  async validateSession() {
    try {
      return await this.request('GET', '/api/v1/auth/cli/validate');
    } catch (error) {
      return null;
    }
  }

  /**
   * Refresh CLI session
   */
  async refreshSession() {
    try {
      const session = configManager.getSession();
      if (!session || !session.token) {
        throw new Error('No session to refresh');
      }

      const response = await this.request('POST', '/api/v1/auth/cli/refresh', {
        token: session.token,
      });

      // Update session
      configManager.saveSession({
        ...session,
        token: response.token,
        expiresAt: response.expiresAt,
      });

      return response;
    } catch (error) {
      configManager.clearSession();
      throw error;
    }
  }

  /**
   * Get CLI login URL with state parameter for CSRF protection
   * @param {string} state - The state token generated by the CLI
   * @param {string|null} provider - Optional OAuth provider for direct auth
   * @returns {string} The login URL
   */
  getLoginUrl(state, provider = null) {
    const backendUrl = configManager.getBackendUrl();
    const callbackUrl = 'http://localhost:3000/callback';

    if (provider) {
      // Direct OAuth provider URL
      return `${backendUrl}/api/auth/oauth-signup?provider=${provider}&sessionType=cli&state=${state}&callback=${encodeURIComponent(callbackUrl)}`;
    } else {
      // Provider selection page
      return `${backendUrl}/auth/cli-login?state=${state}&callback=${encodeURIComponent(callbackUrl)}`;
    }
  }

  /**
   * List API keys for an organization
   * Returns: { keys, limit, currentCount, canCreateMore, limitDescription }
   */
  async listApiKeys(organizationId) {
    return await this.request('GET', `/api/v1/api-keys/list?organizationId=${organizationId}`);
  }

  /**
   * Generate API key for organization
   * Note: This calls Convex action directly, requires session
   */
  async generateApiKey(organizationId, name, scopes = ['*']) {
    return await this.request('POST', `/api/v1/api-keys/generate`, {
      organizationId,
      name,
      scopes,
    });
  }

  /**
   * Get organizations for current user
   */
  async getOrganizations() {
    return await this.request('GET', '/api/v1/organizations');
  }

  /**
   * Create organization
   */
  async createOrganization(name) {
    return await this.request('POST', '/api/v1/organizations', {
      name,
    });
  }

  // ============================================
  // Connected Applications API
  // ============================================

  /**
   * Check if an application already exists for this project path
   * @param {string} organizationId - The organization ID
   * @param {string} projectPathHash - SHA256 hash of the project path
   * @returns {Promise<{found: boolean, application?: object}>}
   */
  async checkExistingApplication(organizationId, projectPathHash) {
    try {
      return await this.request(
        'GET',
        `/api/v1/cli/applications/by-path?organizationId=${organizationId}&hash=${projectPathHash}`
      );
    } catch (error) {
      // If 404, no existing app found
      if (error.status === 404) {
        return { found: false };
      }
      throw error;
    }
  }

  /**
   * Register a new connected application
   * @param {object} data - Application registration data
   * @returns {Promise<{applicationId: string, apiKey?: object, backendUrl: string}>}
   */
  async registerApplication(data) {
    return await this.request('POST', '/api/v1/cli/applications', data);
  }

  /**
   * Update an existing connected application
   * @param {string} applicationId - The application ID
   * @param {object} updates - Fields to update
   * @returns {Promise<object>}
   */
  async updateApplication(applicationId, updates) {
    return await this.request('PATCH', `/api/v1/cli/applications/${applicationId}`, updates);
  }

  /**
   * Get application details
   * @param {string} applicationId - The application ID
   * @returns {Promise<object>}
   */
  async getApplication(applicationId) {
    return await this.request('GET', `/api/v1/cli/applications/${applicationId}`);
  }

  /**
   * List all connected applications for an organization
   * @param {string} organizationId - The organization ID
   * @returns {Promise<{applications: object[]}>}
   */
  async listApplications(organizationId) {
    return await this.request('GET', `/api/v1/cli/applications?organizationId=${organizationId}`);
  }
}

module.exports = new BackendClient();

