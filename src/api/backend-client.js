/**
 * Backend API Client
 * Handles communication with L4YERCAK3 backend API
 */

const crypto = require('crypto');
const fetch = require('node-fetch');
const configManager = require('../config/config-manager');

// API Base URL - All CLI API endpoints go through Convex HTTP
const API_BASE_URL = 'https://aromatic-akita-723.convex.site';

// App URL - Only used for browser login page (Next.js serves the OAuth UI)
const APP_URL = 'https://app.l4yercak3.com';

class BackendClient {
  constructor() {
    this.baseUrl = API_BASE_URL;
    this.appUrl = APP_URL;
  }

  /**
   * Generate a cryptographically secure state token for CSRF protection
   */
  generateState() {
    return crypto.randomBytes(32).toString('hex');
  }

  /**
   * Get headers for API requests
   */
  getHeaders() {
    const session = configManager.getSession();
    const headers = {
      'Content-Type': 'application/json',
    };

    if (session && session.token) {
      headers['Authorization'] = `Bearer ${session.token}`;
    }

    return headers;
  }

  /**
   * Make API request
   * All CLI API endpoints go through the Convex HTTP base URL
   * Returns response data with error details preserved for specific handling
   */
  async request(method, endpoint, data = null) {
    const url = `${this.baseUrl}${endpoint}`;
    const headers = this.getHeaders();
    const options = {
      method,
      headers,
    };

    if (data && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {
      options.body = JSON.stringify(data);
    }

    // Debug logging - enable with L4YERCAK3_DEBUG=1
    if (process.env.L4YERCAK3_DEBUG) {
      console.log('\n[DEBUG] API Request:');
      console.log(`  URL: ${url}`);
      console.log(`  Method: ${method}`);
      console.log(`  Headers: ${JSON.stringify(headers, null, 2)}`);
      if (options.body) {
        console.log(`  Body: ${options.body}`);
      }
    }

    try {
      const response = await fetch(url, options);

      // Debug: log raw response info
      if (process.env.L4YERCAK3_DEBUG) {
        console.log('[DEBUG] API Response:');
        console.log(`  Status: ${response.status} ${response.statusText}`);
        console.log(`  Headers: ${JSON.stringify(Object.fromEntries(response.headers.entries()), null, 2)}`);
      }

      const responseData = await response.json();

      if (process.env.L4YERCAK3_DEBUG) {
        console.log(`  Body: ${JSON.stringify(responseData, null, 2)}\n`);
      }

      if (!response.ok) {
        // Create error with additional details from backend
        const error = new Error(responseData.message || responseData.error || `API request failed: ${response.status}`);
        error.code = responseData.code || 'UNKNOWN_ERROR';
        error.suggestion = responseData.suggestion || null;
        error.upgradeUrl = responseData.upgradeUrl || null;
        error.upgradeCommand = responseData.upgradeCommand || null;
        error.status = response.status;
        throw error;
      }

      return responseData;
    } catch (error) {
      if (process.env.L4YERCAK3_DEBUG) {
        console.log(`[DEBUG] Request error: ${error.message}`);
      }
      if (error.message.includes('fetch')) {
        throw new Error(`Network error: Could not connect to backend at ${this.baseUrl}`);
      }
      throw error;
    }
  }

  /**
   * Validate CLI session
   */
  async validateSession() {
    try {
      return await this.request('GET', '/api/v1/auth/cli/validate');
    } catch (error) {
      return null;
    }
  }

  /**
   * Refresh CLI session
   */
  async refreshSession() {
    try {
      const session = configManager.getSession();
      if (!session || !session.token) {
        throw new Error('No session to refresh');
      }

      const response = await this.request('POST', '/api/v1/auth/cli/refresh', {
        token: session.token,
      });

      // Update session
      configManager.saveSession({
        ...session,
        token: response.token,
        expiresAt: response.expiresAt,
      });

      return response;
    } catch (error) {
      configManager.clearSession();
      throw error;
    }
  }

  /**
   * Revoke CLI session (logout on backend)
   * This cleans up the session from the database
   */
  async revokeSession() {
    try {
      const session = configManager.getSession();
      if (!session || !session.token) {
        return { success: true }; // Nothing to revoke
      }

      return await this.request('POST', '/api/v1/auth/cli/revoke');
    } catch (error) {
      // Even if revoke fails, we'll clear locally
      // Log but don't throw - user still wants to logout
      console.error('Warning: Could not revoke session on backend:', error.message);
      return { success: false, error: error.message };
    }
  }

  /**
   * Get CLI login URL with state parameter for CSRF protection
   * Browser login is served by Next.js at APP_URL (not the Convex API URL)
   * @param {string} state - The state token generated by the CLI
   * @param {string|null} provider - Optional OAuth provider for direct auth
   * @returns {string} The login URL
   */
  getLoginUrl(state, provider = null) {
    // Use port 3333 to avoid conflicts with Next.js dev server (port 3000)
    const callbackUrl = 'http://localhost:3333/callback';

    if (provider) {
      // Direct OAuth provider URL
      return `${this.appUrl}/api/auth/oauth-signup?provider=${provider}&sessionType=cli&state=${state}&callback=${encodeURIComponent(callbackUrl)}`;
    } else {
      // Provider selection page
      return `${this.appUrl}/auth/cli-login?state=${state}&callback=${encodeURIComponent(callbackUrl)}`;
    }
  }

  /**
   * List API keys for an organization
   * Returns: { keys, limit, currentCount, canCreateMore, limitDescription }
   */
  async listApiKeys(organizationId) {
    return await this.request('GET', `/api/v1/auth/cli/api-keys?organizationId=${organizationId}`);
  }

  /**
   * Generate API key for organization
   */
  async generateApiKey(organizationId, name, scopes = ['*']) {
    return await this.request('POST', `/api/v1/auth/cli/api-keys`, {
      organizationId,
      name,
      scopes,
    });
  }

  /**
   * Get organizations for current user
   */
  async getOrganizations() {
    return await this.request('GET', '/api/v1/auth/cli/organizations');
  }

  /**
   * Create organization
   */
  async createOrganization(name) {
    return await this.request('POST', '/api/v1/auth/cli/organizations', {
      name,
    });
  }

  // ============================================
  // Connected Applications API
  // ============================================

  /**
   * Check if an application already exists for this project path
   * @param {string} organizationId - The organization ID
   * @param {string} projectPathHash - SHA256 hash of the project path
   * @returns {Promise<{found: boolean, application?: object}>}
   */
  async checkExistingApplication(organizationId, projectPathHash) {
    try {
      return await this.request(
        'GET',
        `/api/v1/cli/applications/by-path?organizationId=${organizationId}&hash=${projectPathHash}`
      );
    } catch (error) {
      // If 404, no existing app found
      if (error.status === 404) {
        return { found: false };
      }
      throw error;
    }
  }

  /**
   * Register a new connected application
   * @param {object} data - Application registration data
   * @returns {Promise<{applicationId: string, apiKey?: object, backendUrl: string}>}
   */
  async registerApplication(data) {
    return await this.request('POST', '/api/v1/cli/applications', data);
  }

  /**
   * Update an existing connected application
   * @param {string} applicationId - The application ID
   * @param {object} updates - Fields to update
   * @returns {Promise<object>}
   */
  async updateApplication(applicationId, updates) {
    return await this.request('PATCH', `/api/v1/cli/applications/${applicationId}`, updates);
  }

  /**
   * Get application details
   * @param {string} applicationId - The application ID
   * @returns {Promise<object>}
   */
  async getApplication(applicationId) {
    return await this.request('GET', `/api/v1/cli/applications/${applicationId}`);
  }

  /**
   * List all connected applications for an organization
   * @param {string} organizationId - The organization ID
   * @returns {Promise<{applications: object[]}>}
   */
  async listApplications(organizationId) {
    return await this.request('GET', `/api/v1/cli/applications?organizationId=${organizationId}`);
  }

  /**
   * Sync application data
   * @param {string} applicationId - The application ID
   * @param {object} syncData - Sync configuration (direction, models)
   * @returns {Promise<object>}
   */
  async syncApplication(applicationId, syncData) {
    return await this.request('POST', `/api/v1/cli/applications/${applicationId}/sync`, syncData);
  }
}

module.exports = new BackendClient();

