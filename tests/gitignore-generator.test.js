/**
 * Tests for Gitignore Generator
 */

const fs = require('fs');
const path = require('path');

jest.mock('fs');

const GitignoreGenerator = require('../src/generators/gitignore-generator');

describe('GitignoreGenerator', () => {
  const mockProjectPath = '/test/project';
  const mockGitignorePath = path.join(mockProjectPath, '.gitignore');

  beforeEach(() => {
    jest.clearAllMocks();
    fs.existsSync.mockReturnValue(false);
    fs.writeFileSync.mockReturnValue(undefined);
  });

  describe('generate', () => {
    it('creates new .gitignore with L4YERCAK3 entries', () => {
      fs.existsSync.mockReturnValue(false);

      const result = GitignoreGenerator.generate({ projectPath: mockProjectPath });

      expect(result).toBe(mockGitignorePath);
      expect(fs.writeFileSync).toHaveBeenCalled();

      const writtenContent = fs.writeFileSync.mock.calls[0][1];
      expect(writtenContent).toContain('# L4YERCAK3 Configuration');
      expect(writtenContent).toContain('.env.local');
      expect(writtenContent).toContain('.env*.local');
      expect(writtenContent).toContain('.l4yercak3/');
    });

    it('appends to existing .gitignore', () => {
      fs.existsSync.mockReturnValue(true);
      fs.readFileSync.mockReturnValue(`# Existing gitignore
node_modules/
.DS_Store
`);

      const result = GitignoreGenerator.generate({ projectPath: mockProjectPath });

      expect(result).toBe(mockGitignorePath);

      const writtenContent = fs.writeFileSync.mock.calls[0][1];
      expect(writtenContent).toContain('node_modules/');
      expect(writtenContent).toContain('.DS_Store');
      expect(writtenContent).toContain('# L4YERCAK3 Configuration');
      expect(writtenContent).toContain('.env.local');
    });

    it('returns null when all entries already exist', () => {
      fs.existsSync.mockReturnValue(true);
      fs.readFileSync.mockReturnValue(`# L4YERCAK3 Configuration
# Auto-generated by @l4yercak3/cli
.env.local
.env*.local
.l4yercak3/
`);

      const result = GitignoreGenerator.generate({ projectPath: mockProjectPath });

      expect(result).toBeNull();
      expect(fs.writeFileSync).not.toHaveBeenCalled();
    });

    it('adds missing entries when some already exist', () => {
      fs.existsSync.mockReturnValue(true);
      fs.readFileSync.mockReturnValue(`# L4YERCAK3 Configuration
.env.local
`);

      GitignoreGenerator.generate({ projectPath: mockProjectPath });

      const writtenContent = fs.writeFileSync.mock.calls[0][1];
      expect(writtenContent).toContain('.env*.local');
      expect(writtenContent).toContain('.l4yercak3/');
    });

    it('adds newline before section if file does not end with newline', () => {
      fs.existsSync.mockReturnValue(true);
      fs.readFileSync.mockReturnValue('node_modules/');

      GitignoreGenerator.generate({ projectPath: mockProjectPath });

      const writtenContent = fs.writeFileSync.mock.calls[0][1];
      // Should have newline between existing content and new section
      expect(writtenContent).toMatch(/node_modules\/\n\n# L4YERCAK3 Configuration/);
    });

    it('handles whitespace variations in existing entries', () => {
      fs.existsSync.mockReturnValue(true);
      fs.readFileSync.mockReturnValue(`# Some config
  .env.local
.env*.local
  .l4yercak3/
# L4YERCAK3 Configuration
`);

      const result = GitignoreGenerator.generate({ projectPath: mockProjectPath });

      expect(result).toBeNull();
    });
  });
});
