/**
 * Tests for File Utilities
 */

const crypto = require('crypto');
const path = require('path');

jest.mock('fs');
jest.mock('inquirer');

const fs = require('fs');
const inquirer = require('inquirer');

// Must require after mocks are set up
const {
  GENERATED_HEADER,
  isGeneratedFile,
  checkFileOverwrite,
  writeFileWithBackup,
  ensureDir,
  generateProjectPathHash,
} = require('../src/utils/file-utils');

describe('File Utilities', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    jest.spyOn(console, 'log').mockImplementation(() => {});
  });

  afterEach(() => {
    console.log.mockRestore();
  });

  describe('generateProjectPathHash', () => {
    it('generates SHA256 hash of absolute project path', () => {
      const projectPath = '/test/project/path';
      const expectedHash = crypto.createHash('sha256')
        .update(path.resolve(projectPath))
        .digest('hex');

      const result = generateProjectPathHash(projectPath);

      expect(result).toBe(expectedHash);
      expect(result).toHaveLength(64); // SHA256 produces 64 hex chars
    });

    it('generates same hash for same path', () => {
      const projectPath = '/consistent/path';

      const hash1 = generateProjectPathHash(projectPath);
      const hash2 = generateProjectPathHash(projectPath);

      expect(hash1).toBe(hash2);
    });

    it('generates different hashes for different paths', () => {
      const path1 = '/path/one';
      const path2 = '/path/two';

      const hash1 = generateProjectPathHash(path1);
      const hash2 = generateProjectPathHash(path2);

      expect(hash1).not.toBe(hash2);
    });

    it('handles relative paths by resolving to absolute', () => {
      const relativePath = './my-project';
      const absolutePath = path.resolve(relativePath);
      const expectedHash = crypto.createHash('sha256')
        .update(absolutePath)
        .digest('hex');

      const result = generateProjectPathHash(relativePath);

      expect(result).toBe(expectedHash);
    });
  });

  describe('isGeneratedFile', () => {
    it('returns false if file does not exist', () => {
      fs.existsSync.mockReturnValue(false);

      expect(isGeneratedFile('/nonexistent/file.js')).toBe(false);
    });

    it('returns true if file contains generated header', () => {
      fs.existsSync.mockReturnValue(true);
      fs.readFileSync.mockReturnValue(`// ${GENERATED_HEADER}\n// Some content`);

      expect(isGeneratedFile('/test/file.js')).toBe(true);
    });

    it('returns false if file does not contain generated header', () => {
      fs.existsSync.mockReturnValue(true);
      fs.readFileSync.mockReturnValue('// Manual file content\nconst x = 1;');

      expect(isGeneratedFile('/test/file.js')).toBe(false);
    });

    it('returns false if file read throws error', () => {
      fs.existsSync.mockReturnValue(true);
      fs.readFileSync.mockImplementation(() => {
        throw new Error('Read error');
      });

      expect(isGeneratedFile('/test/file.js')).toBe(false);
    });
  });

  describe('checkFileOverwrite', () => {
    it('returns write if file does not exist', async () => {
      fs.existsSync.mockReturnValue(false);

      const result = await checkFileOverwrite('/new/file.js');

      expect(result).toBe('write');
    });

    it('returns write if file is generated by us', async () => {
      fs.existsSync.mockReturnValue(true);
      fs.readFileSync.mockReturnValue(`// ${GENERATED_HEADER}\ncontent`);

      const result = await checkFileOverwrite('/test/file.js');

      expect(result).toBe('write');
    });

    it('returns skip if defaultAction is skip', async () => {
      fs.existsSync.mockReturnValue(true);
      fs.readFileSync.mockReturnValue('manual content');

      const result = await checkFileOverwrite('/test/file.js', { defaultAction: 'skip' });

      expect(result).toBe('skip');
    });

    it('prompts user if file exists and is not generated', async () => {
      fs.existsSync.mockReturnValue(true);
      fs.readFileSync.mockReturnValue('manual content');
      inquirer.prompt.mockResolvedValue({ action: 'backup' });

      const result = await checkFileOverwrite('/test/file.js');

      expect(inquirer.prompt).toHaveBeenCalled();
      expect(result).toBe('backup');
    });
  });

  describe('writeFileWithBackup', () => {
    it('returns null if action is skip', () => {
      const result = writeFileWithBackup('/test/file.js', 'content', 'skip');

      expect(result).toBeNull();
      expect(fs.writeFileSync).not.toHaveBeenCalled();
    });

    it('creates backup if action is backup', () => {
      fs.existsSync.mockReturnValue(true);

      writeFileWithBackup('/test/file.js', 'new content', 'backup');

      expect(fs.copyFileSync).toHaveBeenCalledWith('/test/file.js', '/test/file.js.backup');
      expect(fs.writeFileSync).toHaveBeenCalledWith('/test/file.js', 'new content', 'utf8');
    });

    it('writes file directly if action is write', () => {
      fs.existsSync.mockReturnValue(true);

      const result = writeFileWithBackup('/test/file.js', 'content', 'write');

      expect(fs.copyFileSync).not.toHaveBeenCalled();
      expect(fs.writeFileSync).toHaveBeenCalledWith('/test/file.js', 'content', 'utf8');
      expect(result).toBe('/test/file.js');
    });
  });

  describe('ensureDir', () => {
    it('creates directory if it does not exist', () => {
      fs.existsSync.mockReturnValue(false);

      ensureDir('/test/dir');

      expect(fs.mkdirSync).toHaveBeenCalledWith('/test/dir', { recursive: true });
    });

    it('does nothing if directory exists', () => {
      fs.existsSync.mockReturnValue(true);

      ensureDir('/test/dir');

      expect(fs.mkdirSync).not.toHaveBeenCalled();
    });
  });
});
